---
layout: post
# layout: default
title:  "C++ Basis"
date:   2019-03-17 21:15:00 +0800
---

---
# <font size="5">How C++ works</font>

* Anything that begins with a hash(#) is a **preprocessor statement**. The first things that a compiler does when it receives the source files is to preprocesses all the preprocessor statements. “#”开头的是预处理语句，编译器首先进行预处理。

* During compilation, all CPP files get compiled. Header files will not be compiled. They are pasted into CPP files via the preprocessor statements(#include<>) and that's when they get compiled. 头文件通过#include被复制到CPP文件里，否则，它们不会被编译。

* The result of compiling the CPP files are some individual OBJ files(one for each CPP files). We need a tool to stitch them together into one EXE file. That tool is the **linker**. 各个CPP文件被编译成独立的OBJ文件，链接器负责把它们连接起来组成EXE文件。

* When you declare a function/symbol in one file but forget to define it, the compiler will not complain. It just trust you that there's a definition somewhere. But the linker's job is to resolve the symbol. It has to wire up all the functions. When it cannot find a definition anywhere, there's a linker error. 当你声明了函数却没有定义的时候，编译器不会报错。但链接器需要找到函数的定义，如果找不到，就会产生链接器错误。

---
# <font size="5">静态/动态绑定</font>

* 静态类型（static class）在编译期确定，即**静态绑定**（static binding）；动态类型（dynamic class）在运行期确定，即**动态绑定**（dynamic binding）。
```C++
ClassA *pa = new ClassB();      // 静态类型是ClassA，动态类型是ClassB
ClassB *pb = new ClassC();      // 静态类型ClassB，动态类型ClassC
pa = pb;                        // pa的动态类型可以改变，运行时变为pb的动态类型ClassC
```

* 非虚函数一般都是静态绑定，而**虚函数**（virtual）都是动态绑定，以此实现多态。

* 如果调用动态绑定的函数（虚函数），则先在对象的动态类型中查找函数实现，如果找不到，再在静态类型中查找；如果调用静态绑定函数，必须在静态类型中有实现，否则不通过编译。

* 由于静态绑定，如果一个对象的静态类型是父类，动态类型是子类，调用非虚的析构函数时，会调用父类的析构函数，这样可能会使析构的时候，对象的子类相关的内存没有被清理干净。解决方法是把析构函数也设为虚函数。

([cnblogs][binding-c++])

---
# <font size="5">虚函数和多态的实现</font>

* 存在虚函数的类，有一个一维的虚函数的表，**虚表（vtable）**，里面存储着虚函数们的指针。类的对象有一个指向虚表开始的虚指针。虚表和类对应，虚表指针和对象对应。如果子类没有**重写（override）**虚函数，那么子类的vtable存储的函数指针和父类的一样。虚函数在运行阶段才被resolve（例子参考[dynamic-static-binding.cpp][dsb]）。

    > Override重写：子类重写父类的虚函数    
    > Overload重载：名称相同，参数列表不同的函数

* **纯虚函数**：virtual func() = 0;

* **抽象类**：至少有一个纯虚函数的类。


([cnblogs][duotai-c++])

---
# <font size="5">静态成员和常量</font>

### **static**
静态成员在该类型的所有对象中共享。所有静态成员（包括static const静态常量）一起存储，不是存储在对象中。通常可以用来统计该类型所有对象的总数。

**非常量的静态成员（static）的初始化应该在方法文件中，而不是类声明文件中，**这是因为类声明位于头文件中，可能有多个文件包含了这个头文件，将出现多个初始化语句副本，引发错误；同时，static成员由整个类共享，所以不能在对象的构造函数中进行初始化。可以在方法文件里面，类声明之外使用单独的语句初始化static成员：
```C++
int SomeClass::a_static_member = 10;        // 注意：指定类型，指出作用域，但是不应包括static关键字
```

### **static const**
**静态常量（static const）**可以在声明中初始化。是**在整个类中都恒定的静态常量。**

### **const**
**常量（const）数据成员不能在声明中初始化**，因为声明类并没有创建对象，在创建对象前，并没有存储值的空间。不过与static不同的是，const数据成员可以通过类的构造函数的初始化列表进行初始化。const只对于某个对象而言是常量，但对于整个类而言可以是变量，而static由整个类共享。

([cnblogs][static-const])
([C++-Primer-Plus:p550-ClassScopeConstants/p628-DynamicMemory&Classes][static-const-c++primer])

# <font size="5">模板类Template</font>
---

```C++
template <typename Type>    // or: template <class Type>
class Stack
{
private:
    enum {MAX = 10};
    Type items[MAX];
    int top;
public:
    Stack();
    bool push(const Type & item);
    bool pop(Type & item);
    // ...
};

template <typename Type>
Stack<Type>::Stack()
{
    top = 0;
}

// to use the templates
Stack<int> kernels;
Stack<string> colonels;
```


[binding-c++]: https://www.cnblogs.com/lizhenghn/p/3657717.html
[dsb]: ../../../assets/src/dynamic-static-binding.cpp
[duotai-c++]: https://www.cnblogs.com/cxq0017/p/6074247.html
[static-const]: https://www.cnblogs.com/phpzhou/p/6390869.html
[static-const-c++primer]: http://faculty.euc.ac.cy/scharalambous/csc132/books/c%2B%2B_book%201.pdf